
(macro (aif form)
  `(let ((it ,(cadr form)))
     (if it
         ,(caddr form)
         ,(if (pair? (cdddr form))
              (cadddr form)
              #f))))

(macro awhen
  (lambda (form)
    (apply (lambda (awhen test . body)
             `(aif ,test (begin ,@body) #f))
           form)))

(define identity (lambda (x) x))

(define constantly
  (lambda (x)
    (lambda _ x)))

(define ignore (constantly #f))

(define compose
  (lambda fs
    (cl:reduce (lambda (f g)
                 (lambda x
                   (f (apply g x))))
               fs)))

(define partial
  (lambda (f . fixed)
    (lambda args
      (apply f (append fixed args)))))

(define negate
  (lambda (f)
    (lambda args
      (not (apply f args)))))

(define orf
  (lambda fs
    (lambda x
      (cl:some (lambda (f)
                 (apply f x))
               fs))))

(define nth
  (lambda (n lst)
    ;; I miss nil = false semantics...
    (and (<= n (pred (length lst)))
         (list-ref lst n))))

(macro seq-let
  (lambda (form)
    (apply (lambda (seq-let vars seq . body)
             (let ((seq-var (gensym)))
               `(let (,@(map (lambda (v)
                              (list v #f))
                            vars)
                      (,seq-var ,seq))
                  (if (or (null? ,seq-var) (not ,seq-var))
                      #f
                      (begin
                        ,@(let loop ((i 0) (vars vars) (form '()))
                           (if (null? vars)
                               form
                               (loop (+ i 1)
                                     (cdr vars)
                                     (cons `(set! ,(car vars) (nth ,i ,seq-var))
                                           form))))
                        ,@body)))))
           form)))

(macro when-let
  (lambda (form)
    (apply (lambda (when-let bindings . body)
             (let loop ((bindings (if (pair? (car bindings))
                                      bindings
                                      (list bindings))))
               (if (null? bindings)
                   `(begin . ,body)
                   `(let ((,(caar bindings) ,(cadar bindings)))
                      (unless (or (not ,(caar bindings))
                                  (null? ,(caar bindings)))
                        ,(loop (cdr bindings)))))))
           form)))

(define string-empty?
  (lambda (str)
    (zero? (string-length str))))

