;;; Lilypond-like language parser & evaluater

;; Example usage:
;; (lily-play-music (*metro* 'get-beat)
;;                  chorus
;;                  (lily-parse-music 'c'' '(g4 a b r g a b r d b a g a b a2)))

;;; Syntax

(define lily-regex-note "([a-g])((?:[ei]s)+)?([',]+)?([^-\\\\]+)?")
(define lily-regex-rest "r([^-\\\\]+)?")
(define lily-regex-acc "[ei]s")
(define lily-regex-os "[',]")
(define lily-regex-dur "([[:digit:]]+)([.]+)?(.+)?")
(define lily-regex-dur-multi "[*]([^*]+)") ; duration multiplier
(define lily-regex-lattr "\\\\([^\\\\]+)")    ; long articulates
(define lily-regex-sattr "-(.)")              ; short articulates

(define lily-map-pc
  (map cons
       '("c" "d" "e" "f" "g" "a" "b")
       '(0 2 4 5 7 9 11)))

(define lily-map-acc
  (map cons '("is" "es") '(1 -1)))

(define lily-map-os
  (map cons '("'" ",") '(1 -1)))



;;; Plugin System

(define lily-command-alist '())

(define lily-command-handler
  (lambda (mexp)
    (cl:some (lambda (plugin)
               (let ((cmds (cdr plugin)))
                 (and (if (procedure? cmds)
                          (cmds mexp)
                          (memq mexp cmds))
                      ;; symbol->function
                      (eval (car plugin)))))
             lily-command-alist)))

(define lily-attr-handlers '())

(define lily-parse-attr
  (lambda (str)
    (map string->sexpr
         (append (regex:match-all str lily-regex-lattr)
                 (regex:match-all str lily-regex-sattr)))))

(define lily-apply-attr
  (lambda (note str)
    (foldl (lambda (note attr)
             (or (cl:some (lambda (handle)
                            (handle note attr))
                          lily-attr-handlers)
                 note))
           note
           (lily-parse-attr str))))



;;; Musical structs

(define lily-music-types '())

(macro lily-deftype
  (lambda (form)
    (apply (lambda (lily-deftype type . fields)
             `(begin
                (defstruct ,type ,@fields)
                (set! lily-music-types (cons ',type lily-music-types))
                ,@(map (lambda (field)
                        (let ((field (if (pair? field) (car field) field)))
                          `(begin
                             ;; Install get/set operators on TYPE into
                             ;; the music-type system.
                             (put ',field
                                  ',type
                                  ',(string->symbol (format "~s.~s" type field)))
                             (put ',(string->symbol (format "~s!" field))
                                  ',type
                                  ',(string->symbol
                                     (format "set!~s.~s" type field))))))
                      fields)))
           form)))

(lily-deftype lily-note
  (pc 0)                                ; pitch class
  (acc 0)                               ; accidental
  (os 0)                                ; octave shift
  pn                                    ; pitch naturale
  pitch
  dur
  (vol #f)
  ;; TODO
  ;; - offset (for arpeggio, glissando, triplet etc.)
  raw)

(lily-deftype lily-rest
  dur)

(lily-deftype lily-phrase
  dur notes)

(lily-deftype lily-chord
  dur notes)

(lily-deftype lily-cmd
  dur cmd)

(define lily-typetag
  (lambda (ly)
    (and (vector? ly) (vector-ref ly 0))))

(define lily-music?
  (lambda (ly)
    (aif (lily-typetag ly)
         (memq it lily-music-types))))

(define lily-copy vector-copy)

(define lily-default-note (make-lily-note 'pn 48 'dur 1 'vol 100))

;; Generic operators

;; Data-directed strategy as described in (info "(sicp) 2-4-3")
(define lily-generic
  (lambda (op)
    (lambda (ly . args)
      (let ((proc (get op (lily-typetag ly))))
        (and (not (null? proc))
             (apply (eval proc) ly args))))))

(define lily-duration (lily-generic 'dur))
(define lily-duration! (lily-generic 'dur!))
(define lily-volume (lily-generic 'vol))
(define lily-volume! (lily-generic 'vol!))

;; Some ad-hoc operators

(put 'dur! 'lily-chord
     (lambda (chord dur)
       (for-each (lambda (note)
                   (lily-duration! note dur))
                 (lily-chord.notes chord))
       (set!lily-chord.dur chord dur)))

(put 'vol 'lily-chord
     (lambda (chord)
       (lily-note.vol (car (lily-chord.notes chord)))))

(put 'vol! 'lily-chord
     (lambda (chord vol)
       (for-each (lambda (note)
                   (lily-volume! note vol))
                 (lily-chord.notes chord))))



;;; Parser

(define lily-symbol-peek?
  (lambda (sym char)
    (and (symbol? sym)
         (char=? (string-ref (symbol->string sym) 0) char))))

(define lily-parse-numeric
  (lambda (map regex)
    (lambda (str)
      (foldl (lambda (n x)
               (+ (cdr (assoc x map)) n))
             0
             (regex:match-all str regex)))))

(define lily-parse-acc
  (lily-parse-numeric lily-map-acc lily-regex-acc))

(define lily-parse-os
  (lily-parse-numeric lily-map-os lily-regex-os))

(define lily-analyze-dur-parts
  (lambda (parts)
    (if (pair? parts)
        (compose (if (pair? (cdr parts))
                     (lily-analyze-dur-multi (cadr parts))
                     identity)
                 (lily-analyze-dur-dot (car parts)))
        identity)))

(define lily-analyze-dur-dot
  (lambda (dot)
    (lambda (dur)
      (foldl (lambda (acc n)
               (+ (* dur (expt 2 (- (succ n))))
                  acc))
             dur
             (range (string-length dot))))))

(define lily-analyze-dur-multi
  (lambda (multi)
    (let ((result (regex:matched multi lily-regex-dur-multi)))
      (if (null? result)
          identity
          (lambda (dur)
            (* dur (string->number (cadr result))))))))

(define lily-in-beats
  (lambda (dur)
    (* 4 (/ 1 dur))))

(define lily-parse-dur
  (lambda (dur)
    (let ((result (regex:matched dur lily-regex-dur)))
      (if (null? result)
          #f
          (let ((parts (cdr result)))
            ((lily-analyze-dur-parts (cdr parts))
             (lily-in-beats (string->number (car parts)))))))))

(define lily-parse-note
  (lambda (str)
    (seq-let (raw pc acc os dur) (regex:matched str lily-regex-note)
      (make-lily-note 'pc (cdr (assoc pc lily-map-pc))
                      'acc (if acc (lily-parse-acc acc) 0)
                      'os (if os (lily-parse-os os) 0)
                      'dur (if dur (lily-parse-dur dur) #f)
                      'raw raw))))

(define lily-serialize-music
  (lambda (music)
    (letrec ((accum
              (lambda (note next)
                (cons note (next accum)))))
      (music accum))))

(define lily-serialize-notes
  (lambda (base mexp)
    (lily-serialize-music (lily-parse-music~ base mexp))))

(define lily-parse-phrase
  ;; Parse given musical expressions all at once, to e.g., obtain the
  ;; entire duration.
  (lambda (base mexp)
    (let ((notes (lily-serialize-notes base mexp)))
      (make-lily-phrase 'dur (foldl (lambda (acc note)
                                      (+ acc (lily-duration note)))
                                    0
                                    notes)
                        'notes notes))))

(define lily-lex
  ;; Separate brackets with notes.
  (lambda (mexp)
    (let ((delim-start
           (lambda (str)
             (let ((m (regex:matched str "^([<{])(.+)")))
               (and (pair? m) (map string->sexpr (cdr m))))))
          (delim-end
           (lambda (str)
             (let* ((end-rx "([^>}]*)([>}][^>}]*)")
                    (m (regex:match-all str end-rx)))
               (and (pair? m)
                    (apply cl:nconc
                           (map (lambda (str)
                                  (map string->sexpr
                                       (filter (lambda (str)
                                                 (not (string=? str "")))
                                               (cdr
                                                (regex:matched str end-rx)))))
                                m)))))))
      (foldr (lambda (term acc)
               (let ((str (format "~s" term)))
                 (cond ((delim-start str) => (lambda (terms)
                                               (append terms acc)))
                       ((delim-end str) => (lambda (terms)
                                             (append terms acc)))
                       (else (cons term acc)))))
             '()
             mexp))))

(define lily-parse-brackets
  ;; (lily-parse-brackets mexp '< '> (lambda (notes attr mexp)))
  (lambda (mexp start end k)
    (letrec ((loop
              (lambda (mexp nest notes)
                (continue (car mexp)
                          (lambda (note)
                            (loop (cdr mexp)
                                  (if (eq? note start) (succ nest) nest)
                                  (cons note notes)))
                          (lambda (attr)
                            (if (zero? nest)
                                (k (reverse notes) attr (cdr mexp))
                                (loop (cdr mexp)
                                      (pred nest)
                                      (cons (car mexp) notes)))))))
             (continue
              (lambda (mexp next finally)
                (let ((m (regex:matched (atom->string mexp)
                                        (format "^~s(.*)" end))))
                  (if (null? m)
                      (next mexp)
                      (finally (cadr m)))))))
      (and (eq? (car mexp) start)
           (loop (cdr mexp) 0 '())))))

(define lily-parse-rest
  (lambda (str)
    (seq-let (_ dur) (regex:matched str lily-regex-rest)
      (make-lily-rest 'dur (and dur (lily-parse-dur dur))))))

(define lily-parse-mexp
  (lambda (prev mexp)
    (cond ((lily-music? mexp) mexp)
          ((lily-command-handler mexp) => identity)
          ((symbol? mexp)
           (let ((str (symbol->string mexp)))
             (aif (or (lily-parse-note str)
                      (lily-parse-rest str))
                  (lily-rel-pitch prev (lily-apply-attr it str))))))))

(define lily-calc-pitch
  (lambda (pn note)
    (let* ((pitch (+ (* (quotient pn 12) 12)
                     (lily-note.pc note)))
           (diff (abs (- pn pitch))))
      (cond ((< diff 7) pitch)
            ((> pitch pn) (- pitch 12))
            (else (+ pitch 12))))))

(define lily-ref-note
  (lambda (ref)
    (cond ((lily-note? ref) ref)
          ((lily-chord? ref)
           (car (lily-chord.notes ref))))))

(define lily-rel-pitch
  ;; Set the octave of NOTE relative to REF.
  (lambda (ref note)
    (when (lily-note? note)
      (let ((pitch
             (+ (lily-calc-pitch (lily-note.pn (lily-ref-note ref)) note)
                (* (lily-note.os note) 12))))
        (set!lily-note.pn note pitch)
        (set!lily-note.pitch note (+ pitch (lily-note.acc note)))))
    (lily-supplement ref note)))

(define lily-supplement
  (lambda (ref note)
    (unless (lily-duration note)
      (lily-duration! note (lily-duration ref)))
    (unless (lily-volume note)
      (lily-volume! note (lily-volume ref)))
    note))



;;; User Interface

(define lily-parse-music~
  (letrec ((parse
            (lambda (prev mexp)
              (cond
               ((lily-music? mexp)
                (lambda (k)
                  (k mexp (constantly '()))))
               ((pair? mexp)
                (let ((note (lily-parse-mexp prev (car mexp))))
                  (cond
                   ((procedure? note)
                    (lambda (k)
                      (note (car mexp) prev (cdr mexp)
                            (lambda (note last mexp)
                              (k note (parse last mexp))))))
                   (note
                    (lambda (k)
                      (k note
                         (parse
                          ;; Carry over the last note for `lily-rel-pitch' to work.
                          (if (lily-note? note) note prev)
                          (cdr mexp))))))))
               (else (constantly '()))))))
    parse))

(define lily-parse-music
  (lambda (base mexp)
    (lily-parse-music~ (if (lily-note? base)
                           base
                           (lily-parse-mexp lily-default-note base))
                       (lily-lex mexp))))

(define lily-repeat-music
  (lambda (music count)
    (letrec ((notes (lily-serialize-music music))
             (repeat
              (lambda (notes~ count)
                (lambda (k)
                  (cond ((pair? notes~)
                         (k (car notes~)
                            (repeat (cdr notes~) count)))
                        ((> count 1)
                         (k (car notes)
                            (repeat (cdr notes) (pred count)))))))))
      (repeat notes count))))

(define lily-play-music~
  (lambda (beat play music)
    (music
     (lambda (note next)
       (let ((dur (lily-duration note)))
         (cond ((lily-phrase? note)
                (lily-play-music~ beat play
                                  (lily-parse-music~ () (lily-phrase.notes note))))
               ((lily-chord? note)
                (for-each (lambda (note)
                            (lily-play-music~ beat play
                                              (lily-parse-music~ () note)))
                          (lily-chord.notes note)))
               ((lily-cmd? note)
                ((lily-cmd.cmd note)))
               ((lily-note? note)
                (play beat note)))
         (callback (*metro* (+ beat (* 0.5 dur)))
                   'lily-play-music~ (+ beat dur) play next))))))

(define lily-play-music
  (lambda (beat inst music)
    (lily-play-music~ beat
                      (lambda (beat note)
                        (play-note (*metro* beat) inst
                                   (lily-note.pitch note)
                                   (lily-note.vol note)
                                   (*metro* 'dur (lily-duration note))))
                      music)))
