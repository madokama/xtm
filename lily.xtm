;;; Lilypond-like language parser & evaluater

;; Example usage:
;; (lily-play-music (*metro* 'get-beat)
;;                  chorus
;;                  (lily-parse-music 'c'' '(g4 a b r g a b r d b a g a b a2)))

;;; Syntax

(define lily-regex-note "([a-g])((?:[ei]s)+)?([',]+)?([^-\\\\]+)?")
(define lily-regex-rest "r([^-\\\\]+)?")
(define lily-regex-acc "[ei]s")
(define lily-regex-os "[',]")
(define lily-regex-dur "([[:digit:]]+)([.]+)?(.+)?")
(define lily-regex-dur-multi "[*]([^*]+)") ; duration multiplier (not in lilypond)
(define lily-regex-lattr "\\\\([^\\\\]+)")    ; long articulates
(define lily-regex-sattr "-(.)")              ; short articulates

(define lily-map-pc
  (map cons
       '("c" "d" "e" "f" "g" "a" "b")
       '(0 2 4 5 7 9 11)))

(define lily-map-acc
  (map cons '("is" "es") '(1 -1)))

(define lily-map-os
  (map cons '("'" ",") '(1 -1)))



;;; Plugin System

(define lily-command-alist '())

(define lily-command-handler
  (lambda (mexp)
    (cl:some (lambda (plugin)
               (let ((cmds (cdr plugin)))
                 (and (if (procedure? cmds)
                          (cmds mexp)
                          (memq mexp cmds))
                      ;; symbol->function
                      (eval (car plugin)))))
             lily-command-alist)))



;;; Musical structs

(define lily-music-types '())

(macro lily-deftype
  (lambda (form)
    (apply (lambda (lily-deftype type . fields)
             `(begin
                (defstruct ,type ,@fields)
                (set! lily-music-types (cons ',type lily-music-types))
                ,@(map (lambda (field)
                        (let ((f (symbol->string (if (pair? field)
                                                     (car field)
                                                     field))))
                          `(begin
                             ;; Install get/set operators on TYPE into
                             ;; the music-type system.
                             (put ',(string->symbol f)
                                  ',type
                                  (string->symbol
                                   (string-append (symbol->string ',type)
                                                  "." ,f)))
                             (put ',(string->symbol (string-append f "!"))
                                  ',type
                                  (string->symbol
                                   (string-append "set!"
                                                  (symbol->string ',type)
                                                  "." ,f))))))
                      fields)))
           form)))

(lily-deftype lily-note
  (pc 0)                                ; pitch class
  (acc 0)                               ; accidental
  (os 0)                                ; octave shift
  pn                                    ; pitch naturale
  pitch
  dur
  (vol #f)
  ;; TODO
  ;; - offset (for arpeggio, glissando, triplet etc.)
  raw)

(lily-deftype lily-rest
  dur)

(lily-deftype lily-phrase
  dur notes)

(lily-deftype lily-chord
  dur notes)

(lily-deftype lily-cmd
  dur cmd)

(define lily-typetag
  (lambda (ly)
    (and (vector? ly) (vector-ref ly 0))))

(define lily-music?
  (lambda (ly)
    (aif (lily-typetag ly)
         (memq it lily-music-types))))

(define lily-copy vector-copy)

(define lily-default-note (make-lily-note 'pn 48 'dur 1 'vol 100))

;; Generic operators

;; Data-directed strategy as described in (info "(sicp) 2-4-3")
(define lily-generic
  (lambda (op)
    (lambda (ly . args)
      (let ((proc (get op (lily-typetag ly))))
        (and (not (null? proc))
             (apply (eval proc) ly args))))))

(define lily-duration (lily-generic 'dur))
(define lily-duration! (lily-generic 'dur!))
(define lily-volume (lily-generic 'vol))
(define lily-volume! (lily-generic 'vol!))

;; Some ad-hoc operators

(put 'dur! 'lily-chord
     (lambda (chord dur)
       (for-each (lambda (note)
                   (lily-duration! note dur))
                 (lily-chord.notes chord))
       (set!lily-chord.dur chord dur)))

(put 'vol 'lily-chord
     (lambda (chord)
       (lily-note.vol (car (lily-chord.notes chord)))))

(put 'vol! 'lily-chord
     (lambda (chord vol)
       (for-each (lambda (note)
                   (lily-volume! note vol))
                 (lily-chord.notes chord))))



;;; Parser

(define lily-symbol-peek?
  (lambda (sym char)
    (and (symbol? sym)
         (char=? (string-ref (symbol->string sym) 0) char))))

(define lily-parse-numeric
  (lambda (map regex)
    (lambda (str)
      (foldl (lambda (n x)
               (+ (cdr (assoc x map)) n))
             0
             (regex:match-all str regex)))))

(define lily-parse-acc
  (lily-parse-numeric lily-map-acc lily-regex-acc))

(define lily-parse-os
  (lily-parse-numeric lily-map-os lily-regex-os))

(define lily-analyze-dur-parts
  (lambda (parts)
    (if (pair? parts)
        (compose (if (pair? (cdr parts))
                     (lily-analyze-dur-multi (cadr parts))
                     identity)
                 (lily-analyze-dur-dot (car parts)))
        identity)))

(define lily-analyze-dur-dot
  (lambda (dot)
    (lambda (dur)
      (foldl (lambda (acc n)
               (+ (* dur (expt 2 (- (succ n))))
                  acc))
             dur
             (range (string-length dot))))))

(define lily-analyze-dur-multi
  (lambda (multi)
    (let ((result (regex:matched multi lily-regex-dur-multi)))
      (if (null? result)
          identity
          (lambda (dur)
            (* dur (string->number (cadr result))))))))

(define lily-in-beats
  (lambda (dur)
    (* 4 (/ 1 dur))))

(define lily-parse-dur
  (lambda (dur)
    (let ((result (regex:matched dur lily-regex-dur)))
      (if (null? result)
          #f
          (let ((parts (cdr result)))
            ((lily-analyze-dur-parts (cdr parts))
             (lily-in-beats (string->number (car parts)))))))))

(define lily-parse-note
  (lambda (str)
    (seq-let (raw pc acc os dur) (regex:matched str lily-regex-note)
      (make-lily-note 'pc (cdr (assoc pc lily-map-pc))
                      'acc (if acc (lily-parse-acc acc) 0)
                      'os (if os (lily-parse-os os) 0)
                      'dur (if dur (lily-parse-dur dur) #f)
                      'raw raw))))

(define lily-collect-notes
  (lambda (base mexp)
    (letrec ((accum
              (lambda (note next)
                (cons note (next accum)))))
      ((lily-parse-music base mexp) accum))))

(define lily-parse-phrase
  ;; Parse given musical expressions all at once, to e.g., obtain the
  ;; entire duration.
  (lambda (base mexp)
    (let ((notes (lily-collect-notes base mexp)))
      (make-lily-phrase 'dur (foldl (lambda (acc note)
                                      (+ acc (lily-duration note)))
                                    0
                                    notes)
                        'notes notes))))

(define lily-parse-rest
  (lambda (str)
    (let ((result (regex:matched str lily-regex-rest)))
      (if (null? result)
          #f
          (make-lily-rest 'dur (aif (nth 1 result) (lily-parse-dur it)))))))

(define lily-parse-mexp
  (lambda (prev mexp)
    (cond ((lily-music? mexp) mexp)
          ((lily-command-handler mexp) => identity)
          ((symbol? mexp)
           (let ((note (symbol->string mexp)))
             (aif (or (lily-parse-note note)
                      (lily-parse-rest note))
                  (lily-rel-pitch prev it)))))))

(define lily-calc-pitch
  (lambda (pn note)
    (let* ((pitch (+ (* (quotient pn 12) 12)
                     (lily-note.pc note)))
           (diff (abs (- pn pitch))))
      (cond ((< diff 7) pitch)
            ((> pitch pn) (- pitch 12))
            (else (+ pitch 12))))))

(define lily-ref-note
  (lambda (ref)
    (cond ((lily-note? ref) ref)
          ((lily-chord? ref)
           (car (lily-chord.notes ref))))))

(define lily-rel-pitch
  ;; Set the octave of NOTE relative to REF.
  (lambda (ref note)
    (when (lily-note? note)
      (let ((pitch
             (+ (lily-calc-pitch (lily-note.pn (lily-ref-note ref)) note)
                (* (lily-note.os note) 12))))
        (set!lily-note.pn note pitch)
        (set!lily-note.pitch note (+ pitch (lily-note.acc note)))))
    (lily-supplement ref note)))

(define lily-supplement
  (lambda (ref note)
    (unless (lily-duration note)
      (lily-duration! note (lily-duration ref)))
    (unless (lily-volume note)
      (lily-volume! note (lily-volume ref)))
    note))



;;; User Interface

(define lily-parse-music
  (lambda (base mexp)
    (letrec ((parse
              (lambda (prev mexp)
                (cond
                 ((lily-music? mexp)
                  (lambda (k)
                    (k mexp (constantly '()))))
                 ((pair? mexp)
                  (let ((note (lily-parse-mexp prev (car mexp))))
                    (cond
                     ((procedure? note)
                      (lambda (k)
                        (let ((result (note (car mexp) prev (cdr mexp))))
                          (k (car result)
                             (apply parse (cdr result))))))
                     (note
                      (lambda (k)
                        (k note
                           (parse
                            ;; Carry over the last note for `lily-rel-pitch' to work.
                            (if (lily-note? note) note prev)
                            (cdr mexp))))))))
                 (else (constantly '()))))))
      (parse (if (lily-note? base)
                 base
                 (lily-parse-mexp lily-default-note base))
             mexp))))

(define lily-play-music
  (lambda (beat inst music)
    (music
     (lambda (note next)
       (let ((dur (lily-duration note)))
         (cond ((lily-phrase? note)
                (lily-play-music beat inst
                                 (lily-parse-music () (lily-phrase.notes note))))
               ((lily-chord? note)
                (for-each (lambda (note)
                            (lily-play-music beat inst (lily-parse-music () note)))
                          (lily-chord.notes note)))
               ((lily-cmd? note)
                ((lily-cmd.cmd note)))
               ((lily-note? note)
                (play-note (*metro* beat) inst
                           (lily-note.pitch note)
                           (lily-note.vol note)
                           (*metro* 'dur (* dur 1.02))))) ; XXX legato hack
         (callback (*metro* (+ beat (* 0.5 dur)))
                   'lily-play-music (+ beat dur) inst next))))))
