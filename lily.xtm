;;; Lilypond-like language parser & evaluater

;; Example usage:
;; (lily-play-music (*metro* 'get-beat)
;;                  chorus
;;                  (lily-parse-music 'c'' '(g4 a b r g a b r d b a g a b a2)))

;;; Syntax

(define lily-regex-note "([a-g])((?:[ei]s)+)?([',]+)?([^-\\\\]+)?")
(define lily-regex-rest "r([^-\\\\]+)?")
(define lily-regex-acc "[ei]s")
(define lily-regex-os "[',]")
(define lily-regex-dur "([[:digit:]]+)([.]+)?(.+)?")
(define lily-regex-dur-multi "[*]([^*]+)") ; duration multiplier
(define lily-regex-lattr "\\\\([^\\\\]+)")    ; long articulates
(define lily-regex-sattr "-(.)")              ; short articulates

(define lily-map-pc
  (map cons
       '("c" "d" "e" "f" "g" "a" "b")
       '(0 2 4 5 7 9 11)))

(define lily-map-acc
  (map cons '("is" "es") '(1 -1)))

(define lily-map-os
  (map cons '("'" ",") '(1 -1)))



;;; Plugin System

(define lily-command-alist '())

(define lily-command-handler
  (lambda (mexp)
    (cl:some (lambda (plugin)
               (let ((cmds (cdr plugin)))
                 (and (if (procedure? cmds)
                          (cmds mexp)
                          (memq mexp cmds))
                      ;; symbol->function
                      (eval (car plugin)))))
             lily-command-alist)))

(define lily-attr-handlers '())

(define lily-parse-lattr
  (lambda (str)
    (map string->sexpr
         (regex:match-all str lily-regex-lattr))))

(define lily-parse-sattr
  (lambda (str)
    (map (lambda (sh)
           (aif (assoc sh lily-arts-shorthand)
                (cdr it)))
         (regex:match-all str lily-regex-sattr))))

(define lily-parse-attr
  (lambda (str)
    (append (lily-parse-lattr str)
            (lily-parse-sattr str))))

(define lily-apply-attr
  (lambda (note str)
    (foldl (lambda (note attr)
             (or (cl:some (lambda (handle)
                            (handle note attr))
                          lily-attr-handlers)
                 (begin
                   ;; Defer processing till play phase.
                   (lily-articulations! note (cons attr (lily-articulations note)))
                   note)))
           note
           (lily-parse-attr str))))



;;; Musical structs

(define lily-music-types '())

(macro lily-deftype
  (lambda (form)
    (apply (lambda (lily-deftype type . fields)
             `(begin
                (defstruct ,type ,@fields)
                (set! lily-music-types (cons ',type lily-music-types))
                ,@(map (lambda (field)
                        (let ((field (if (pair? field) (car field) field)))
                          `(begin
                             ;; Install get/set operators on TYPE into
                             ;; the music-type system.
                             (put ',field
                                  ',type
                                  ',(string->symbol (format "~s.~s" type field)))
                             (put ',(string->symbol (format "~s!" field))
                                  ',type
                                  ',(string->symbol
                                     (format "set!~s.~s" type field))))))
                      fields)))
           form)))

(lily-deftype lily-note
  (pc 0)                                ; pitch class
  (acc 0)                               ; accidental
  (os 0)                                ; octave shift
  pn                                    ; pitch naturale
  pitch
  dur
  (vol #f)
  arts                                  ; list of articulations
  raw)

(lily-deftype lily-rest
  dur)

(lily-deftype lily-phrase
  dur notes)

(lily-deftype lily-chord
  dur notes (attr ""))

(lily-deftype lily-cmd
  dur cmd)

(define lily-typetag
  (lambda (ly)
    (and (vector? ly) (vector-ref ly 0))))

(define lily-music?
  (lambda (ly)
    (aif (lily-typetag ly)
         (memq it lily-music-types))))

(define lily-copy
  (lambda (ly)
    (cond ((vector? ly)
           (make-vector-with-proc (vector-length ly)
                                  (lambda (i)
                                    (lily-copy (vector-ref ly i)))))
          ((list? ly)
           (map lily-copy ly))
          (else ly))))

(define lily-default-note (make-lily-note 'pn 48 'dur 1 'vol 100))

;; Generic operators

;; Data-directed strategy as described in (info "(sicp) 2-4-3")
(define lily-generic
  (lambda (op)
    (lambda (ly . args)
      (let ((proc (get op (lily-typetag ly))))
        (and (not (null? proc))
             (apply (eval proc) ly args))))))

(define lily-duration (lily-generic 'dur))
(define lily-duration! (lily-generic 'dur!))
(define lily-volume (lily-generic 'vol))
(define lily-volume! (lily-generic 'vol!))
(define lily-articulations (lily-generic 'arts))
(define lily-articulations! (lily-generic 'arts!))
(define lily-notes (lily-generic 'notes))

;; Some ad-hoc operators

(put 'dur! 'lily-chord
     (lambda (chord dur)
       (for-each (lambda (note)
                   (lily-duration! note dur))
                 (lily-notes chord))
       (set!lily-chord.dur chord dur)))

(put 'vol 'lily-chord
     (lambda (chord)
       (lily-volume (car (lily-notes chord)))))

(put 'vol! 'lily-chord
     (lambda (chord vol)
       (for-each (lambda (note)
                   (lily-volume! note vol))
                 (lily-notes chord))))

(put 'arts 'lily-chord
     (lambda (chord arts)
       (lily-articulations (car (lily-notes chord)))))

(put 'arts! 'lily-chord
     (lambda (chord arts)
       (for-each (lambda (note)
                   (lily-articulations! note arts))
                 (lily-notes chord))))



;;; Parser

(define lily-symbol-peek?
  (lambda (sym char)
    (and (symbol? sym)
         (char=? (string-ref (symbol->string sym) 0) char))))

(define lily-parse-numeric
  (lambda (map regex)
    (lambda (str)
      (foldl (lambda (n x)
               (+ (cdr (assoc x map)) n))
             0
             (regex:match-all str regex)))))

(define lily-parse-acc
  (lily-parse-numeric lily-map-acc lily-regex-acc))

(define lily-parse-os
  (lily-parse-numeric lily-map-os lily-regex-os))

(define lily-analyze-dur-parts
  (lambda (parts)
    (if (pair? parts)
        (compose (if (pair? (cdr parts))
                     (lily-analyze-dur-multi (cadr parts))
                     identity)
                 (lily-analyze-dur-dot (car parts)))
        identity)))

(define lily-analyze-dur-dot
  (lambda (dot)
    (lambda (dur)
      (foldl (lambda (acc n)
               (+ (* dur (expt 2 (- (succ n))))
                  acc))
             dur
             (range (string-length dot))))))

(define lily-analyze-dur-multi
  (lambda (multi)
    (let ((result (regex:matched multi lily-regex-dur-multi)))
      (if (null? result)
          identity
          (lambda (dur)
            (* dur (string->number (cadr result))))))))

(define lily-in-beats
  (lambda (dur)
    (* 4 (/ 1 dur))))

(define lily-parse-dur
  (lambda (dur)
    (let ((result (regex:matched dur lily-regex-dur)))
      (if (null? result)
          #f
          (let ((parts (cdr result)))
            ((lily-analyze-dur-parts (cdr parts))
             (lily-in-beats (string->number (car parts)))))))))

(define lily-parse-note
  (lambda (str)
    (seq-let (_ pc acc os dur) (regex:matched str lily-regex-note)
      (make-lily-note 'pc (cdr (assoc pc lily-map-pc))
                      'acc (if acc (lily-parse-acc acc) 0)
                      'os (if os (lily-parse-os os) 0)
                      'dur (if dur (lily-parse-dur dur) #f)
                      'raw str))))

(define lily-serialize-music
  (lambda (music)
    (letrec ((accum
              (lambda (note next)
                (cons note (next accum)))))
      (music accum))))

(define lily-serialize-notes
  (lambda (base mexp)
    (lily-serialize-music (lily-parse-music~ base mexp))))

(define lily-return-phrase
  (lambda (phrase mexp k)
    (k phrase
       ;; Compute the last pitch & dur for the later reference as `prev'.
       (cl:reduce (letrec ((choose
                            (lambda (x y)
                              (cond ((or (lily-note? y) (lily-chord? y)) y)
                                    ((lily-phrase? y)
                                     (cl:reduce choose
                                                (lily-notes y)))
                                    ((lily-phrase? x)
                                     (cl:reduce choose
                                                (lily-notes x)))
                                    (else
                                     (let ((x~ (lily-copy x)))
                                       (lily-duration! x~ (lily-duration y))
                                       x~))))))
                    choose)
                  (lily-notes phrase))
       mexp)))

(define lily-parse-phrase
  ;; Parse given musical expressions all at once, to e.g., obtain the
  ;; entire duration.
  (lambda (base mexp)
    (let ((notes (lily-serialize-notes base mexp)))
      (make-lily-phrase 'dur (foldl (lambda (acc note)
                                      (+ acc (lily-duration note)))
                                    0
                                    notes)
                        'notes notes))))

(define lily-lex
  ;; Separate brackets with notes.
  (lambda (mexp)
    (let* ((delim-start
            (lambda (str)
              (let ((m (regex:matched str "^([<{])(.+)")))
                (and (pair? m) (map string->sexpr (cdr m))))))
           (delim-end
            (lambda (str)
              ;; Split closing bracket only if it directly follows a pitch name.
              (let* ((end-rx "^([a-z]*)([>}][^>}]*)")
                     (m (regex:match-all str end-rx)))
                (and (pair? m)
                     (apply cl:nconc
                            (map (lambda (str)
                                   (map string->sexpr
                                        (filter (negate string-empty?)
                                                (cdr
                                                 (regex:matched str end-rx)))))
                                 m))))))
           (delim (orf delim-start delim-end)))
      (foldr (lambda (term acc)
               (aif (delim (format "~s" term))
                    (append it acc)
                    (cons term acc)))
             '()
             mexp))))

(define lily-parse-brackets
  ;; (lily-parse-brackets mexp '< '> (lambda (notes attr mexp)))
  (lambda (mexp start end k)
    (letrec ((loop
              (lambda (mexp nest notes)
                (continue (car mexp)
                          (lambda (note)
                            (loop (cdr mexp)
                                  (if (eq? note start) (succ nest) nest)
                                  (cons note notes)))
                          (lambda (attr)
                            (if (zero? nest)
                                (k (reverse notes) attr (cdr mexp))
                                (loop (cdr mexp)
                                      (pred nest)
                                      (cons (car mexp) notes)))))))
             (continue
              (lambda (mexp next finally)
                (let ((m (regex:matched (atom->string mexp)
                                        (format "^~s(.*)" end))))
                  (if (null? m)
                      (next mexp)
                      (finally (cadr m)))))))
      (and (eq? (car mexp) start)
           (loop (cdr mexp) 0 '())))))

(define lily-parse-rest
  (lambda (str)
    (seq-let (_ dur) (regex:matched str lily-regex-rest)
      (make-lily-rest 'dur (and dur (lily-parse-dur dur))))))

(define lily-parse-symbol
  (lambda (prev mexp)
    (let ((str (symbol->string mexp)))
      (aif (or (lily-parse-note str)
               (lily-parse-rest str))
           (lily-rel-pitch prev (lily-apply-attr it str))))))

(define lily-parse-mexp
  (lambda (prev mexp)
    (cond ((lily-music? mexp) mexp)
          ((lily-command-handler mexp) => (lambda (handle)
                                            (partial handle mexp prev)))
          ((symbol? mexp)
           (lily-parse-symbol prev mexp)))))

(define lily-calc-pitch
  (lambda (pn note)
    (let* ((pitch (+ (* (quotient pn 12) 12)
                     (lily-note.pc note)))
           (diff (abs (- pn pitch))))
      (cond ((< diff 7) pitch)
            ((> pitch pn) (- pitch 12))
            (else (+ pitch 12))))))

(define lily-ref-note
  (lambda (ref)
    (cond ((lily-note? ref) ref)
          ((lily-chord? ref)
           (car (lily-notes ref))))))

(define lily-rel-pitch
  ;; Set the octave of NOTE relative to REF.
  (lambda (ref note)
    (when (lily-note? note)
      (let ((pitch
             (+ (lily-calc-pitch (lily-note.pn (lily-ref-note ref)) note)
                (* (lily-note.os note) 12))))
        (set!lily-note.pn note pitch)
        (set!lily-note.pitch note (+ pitch (lily-note.acc note)))))
    (lily-supplement ref note)))

(define lily-supplement
  (lambda (ref note)
    (unless (lily-duration note)
      (lily-duration! note (lily-duration ref)))
    (unless (lily-volume note)
      (lily-volume! note (lily-volume ref)))
    note))



;;; User Interface

(define lily-parse-music~
  (letrec ((may-tie
            (lambda (k)
              (lambda (note last mexp)
                (lily-may-tie note mexp
                              (lambda (note mexp)
                                (k note (parse last mexp)))))))
           (parse
            (lambda (prev mexp)
              (cond
               ((lily-music? mexp)
                (lambda (k)
                  (k mexp (constantly '()))))
               ((pair? mexp)
                (let ((note (lily-parse-mexp prev (car mexp))))
                  (cond
                   ((procedure? note)
                    (lambda (k)
                      (note (cdr mexp) (may-tie k))))
                   (note
                    (lambda (k)
                      ((may-tie k)
                       note
                       ;; Carry over the last note for `lily-rel-pitch' to work.
                       (if (lily-rest? note)
                           (let ((prev~ (lily-copy prev)))
                             ;; Inherit duration from rest.
                             (lily-duration! prev~ (lily-duration note))
                             prev~)
                           note)
                       (cdr mexp)))))))
               (else (constantly '()))))))
    parse))

(define lily-parse-music
  (lambda (base mexp)
    (lily-parse-music~ (lily-parse-mexp lily-default-note base)
                       (lily-lex mexp))))

(define lily-repeat-music
  (lambda (music . count)
    (letrec ((notes (lily-serialize-music music))
             (repeat
              (lambda (notes~ count)
                (lambda (k)
                  (cond ((pair? notes~)
                         (k (car notes~)
                            (repeat (cdr notes~) count)))
                        ((> count 1)
                         (k (car notes)
                            (repeat (cdr notes) (pred count)))))))))
      (repeat notes
              (if (pair? count)
                  (car count)
                  2305843009213693951)))))

(define lily-play-voice
  (lambda (beat play music)
    (music
     (lambda (note next)
       (let ((dur (lily-duration note)))
         (cond ((lily-phrase? note)
                (lily-play-voice beat play
                                 (lily-parse-music~ () (lily-notes note))))
               ((lily-chord? note)
                (for-each (lambda (note)
                            (lily-play-voice beat play
                                             (lily-parse-music~ () note)))
                          (lily-notes note)))
               ((lily-cmd? note)
                ((lily-cmd.cmd note)))
               ((lily-note? note)
                (play beat note)))
         (callback (*metro* (+ beat (* 0.5 dur)))
                   'lily-play-voice (+ beat dur) play next))))))

(define lily-call-player
  ;; Wrapper function for custom players.
  (lambda (play)
    (lambda (beat note)
      (let ((arts (lily-articulations note)))
        (play (*metro* beat)
              (lily-note.pitch note)
              (lily-arts-dyn (lily-volume note) arts)
              (lily-arts-dur (*metro* 'dur (lily-duration note))
                             arts))))))

(define lily-play-music
  (lambda (beat inst . voices)
    (for-each (partial lily-play-voice
                       beat
                       (lily-call-player
                        (lambda (time pitch vol dur)
                          (play-note time inst pitch vol dur))))
              voices)))
